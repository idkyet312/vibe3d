#version 450
#extension GL_ARB_separate_shader_objects : enable

// Tile size must match CPU constant
#define TILE_SIZE 16
#define MAX_LIGHTS_PER_TILE 1024

layout(local_size_x = TILE_SIZE, local_size_y = TILE_SIZE, local_size_z = 1) in;

// Input: All lights in the scene
struct PointLight {
    vec3 position;
    float radius;
    vec3 color;
    float intensity;
};

layout(set = 0, binding = 0) uniform CameraUBO {
    mat4 view;
    mat4 projection;
    vec4 position;
} camera;

layout(set = 0, binding = 1) readonly buffer LightBuffer {
    PointLight lights[];
};

// Depth texture from prepass
layout(set = 0, binding = 2) uniform sampler2D depthTexture;

// Output: Light indices per tile
layout(set = 0, binding = 3) buffer VisibleLightIndices {
    uint visibleLightIndices[];
};

layout(set = 0, binding = 4) buffer LightGrid {
    uint lightCount[];
};

layout(push_constant) uniform PushConstants {
    uint numLights;
    uint numTilesX;
    uint numTilesY;
    uint screenWidth;
    uint screenHeight;
} pushConst;

// Shared memory for light culling
shared uint sharedLightCount;
shared uint sharedLightIndices[MAX_LIGHTS_PER_TILE];
shared vec4 frustumPlanes[6];

// Convert screen space to view space
vec3 screenToView(vec2 screenPos, float depth) {
    vec4 clip = vec4(screenPos * 2.0 - 1.0, depth, 1.0);
    vec4 view = inverse(camera.projection) * clip;
    return view.xyz / view.w;
}

// Create frustum for this tile
void createTileFrustum(uint tileX, uint tileY) {
    vec2 tileMin = vec2(tileX, tileY) * TILE_SIZE;
    vec2 tileMax = tileMin + vec2(TILE_SIZE);
    
    vec2 screenMin = tileMin / vec2(pushConst.screenWidth, pushConst.screenHeight);
    vec2 screenMax = tileMax / vec2(pushConst.screenWidth, pushConst.screenHeight);
    
    // Get corner points at near and far planes
    vec3 nearMin = screenToView(screenMin, 0.0);
    vec3 nearMax = screenToView(screenMax, 0.0);
    vec3 farMin = screenToView(screenMin, 1.0);
    vec3 farMax = screenToView(screenMax, 1.0);
    
    // Build frustum planes (in view space)
    vec3 corners[8] = vec3[8](
        nearMin,
        vec3(nearMax.x, nearMin.y, nearMin.z),
        vec3(nearMin.x, nearMax.y, nearMin.z),
        nearMax,
        farMin,
        vec3(farMax.x, farMin.y, farMin.z),
        vec3(farMin.x, farMax.y, farMin.z),
        farMax
    );
    
    // Simplified frustum - use AABB
    vec3 minBounds = min(min(min(corners[0], corners[1]), corners[2]), corners[3]);
    vec3 maxBounds = max(max(max(corners[4], corners[5]), corners[6]), corners[7]);
    
    frustumPlanes[0] = vec4(1, 0, 0, -minBounds.x);
    frustumPlanes[1] = vec4(-1, 0, 0, maxBounds.x);
    frustumPlanes[2] = vec4(0, 1, 0, -minBounds.y);
    frustumPlanes[3] = vec4(0, -1, 0, maxBounds.y);
    frustumPlanes[4] = vec4(0, 0, 1, -minBounds.z);
    frustumPlanes[5] = vec4(0, 0, -1, maxBounds.z);
}

// Test if sphere intersects frustum
bool sphereIntersectsFrustum(vec3 position, float radius) {
    for (int i = 0; i < 6; i++) {
        float dist = dot(frustumPlanes[i].xyz, position) + frustumPlanes[i].w;
        if (dist < -radius) {
            return false;
        }
    }
    return true;
}

void main() {
    uint tileX = gl_WorkGroupID.x;
    uint tileY = gl_WorkGroupID.y;
    uint tileIndex = tileY * pushConst.numTilesX + tileX;
    uint localThreadIndex = gl_LocalInvocationIndex;
    
    // Initialize shared memory
    if (localThreadIndex == 0) {
        sharedLightCount = 0;
        createTileFrustum(tileX, tileY);
    }
    
    barrier();
    
    // Each thread tests a subset of lights
    for (uint i = localThreadIndex; i < pushConst.numLights; i += TILE_SIZE * TILE_SIZE) {
        PointLight light = lights[i];
        
        // Transform light to view space
        vec4 viewPos = camera.view * vec4(light.position, 1.0);
        
        // Test against frustum
        if (sphereIntersectsFrustum(viewPos.xyz, light.radius)) {
            uint index = atomicAdd(sharedLightCount, 1);
            if (index < MAX_LIGHTS_PER_TILE) {
                sharedLightIndices[index] = i;
            }
        }
    }
    
    barrier();
    
    // Write results
    if (localThreadIndex == 0) {
        uint count = min(sharedLightCount, MAX_LIGHTS_PER_TILE);
        lightCount[tileIndex] = count;
    }
    
    // Cooperatively write light indices
    uint offset = tileIndex * MAX_LIGHTS_PER_TILE;
    for (uint i = localThreadIndex; i < min(sharedLightCount, MAX_LIGHTS_PER_TILE); i += TILE_SIZE * TILE_SIZE) {
        visibleLightIndices[offset + i] = sharedLightIndices[i];
    }
}
